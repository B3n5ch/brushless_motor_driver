/**
 * @brief internal speedValue for the PWM signal
 */
static uint8_t _speed = 0;
/**
 * @brief the current velocity of the Motor in turns per second
 * @detail is updated avery AVG_LENGTH steps (6 steps are 1 turn)
 */
static float _current_velocity = 0;
/**
 * @brief the current set velocity value (turns per second)
 */
static float _velocity = 0;
/**
 * @brief used to measure the speed value by counting the timer2 overflows
 */
static uint8_t _ovf_count = 0;

/**
 * @brief the count var for the speed measurement 
 */
static uint8_t _avg_count = AVG_LENGTH;

/**
 * @brief count var for the startup procedure
 * @detail if _startup <> 0 then a startup procedure is needed
 */
static uint8_t _startup = STARTUP_LENGTH;
/** 
 * @brief actual state var which tells the last known position of the motor axis
 */
static uint8_t _state = 1;
/**
 * @brief turn direction 
 */
static int8_t _direction = FORWARD;

/**
 * @brief Init Method to init Timer2, PCINT and Watchdog and the input output Ports
 */
void Brushless_Motorshield::Init()
{
	//Set input Pins for Sensors IN/Without Pull Up
	DDR_SENS_A &= ~(1<<SENS_A);
	DDR_SENS_B &= ~(1<<SENS_B);
	DDR_SENS_C &= ~(1<<SENS_C);

	PORT_SENS_A &= ~(1<<SENS_A);
	PORT_SENS_B &= ~(1<<SENS_B);
	PORT_SENS_C &= ~(1<<SENS_C);
	
	//Set output Ports for Drivers
	DDR_U |= (1<<U);
	DDR_U_INH |= (1<<U_INH);
	DDR_V |= (1<<V);
	DDR_V_INH |= (1<<V_INH);
	DDR_W |= (1<<W);
	DDR_W_INH |= (1<<W_INH);


	PORT_U &= ~(1<<U);
	PORT_U_INH &= ~(1<<U_INH);
	PORT_V &= ~(1<<V);
	PORT_V_INH &= ~(1<<V_INH);
	PORT_W &= ~(1<<W);
	PORT_W_INH &= ~(1<<W_INH);

	cli();
	//Setup PWM for speed (torque) controll
	//TCCR2A mode
	TCCR2A |= (1<<WGM20)|(1<<WGM21);
	// clear TCNT2
	TCNT2 = 0;
	// enable timer 2 overflow and compare match a interrupt
	TIMSK2 |= (1<<TOIE2) | (1<<OCIE2A);// | (1<<OCIE2B);
	// set compare match register to zero
	OCR2A = 0;
	// prescaler = 1, 1 Timerstep = 500 ns, 255 Timersteps = 127.5 usm, fPWM = 7,8 kHz
	TCCR2B = (1<<CS21);

	//Initialize Pin Change interrupts
	PCICR |= (1<<PCIE);
	PCMSK_REG |= (1<<SENSA_PCINT)|(1<<SENSB_PCINT)|(1<<SENSC_PCINT);

	//Enable WD with 500ms Timeout
	wdt_enable(WDTO_500MS);
	// init watchdog as timeout timer; 
	WDTCSR = (1<<WDCE) | (1<<WDIE);
	sei();

	//read State at startup
	readNextState(); 
}

//private methods
/**
 * @brief method to start the motor
 */
void Brushless_Motorshield::startMotor()
{
	//Time delay between stateChange
	uint8_t state_delay = FORCED_MOVE_TIME_START;
	//Set Startup_Speed_Val
	if(_velocity != 0)
		_speed = STARTUP_SPEED_VAL;
	
	//Read actual state for Startup
	readNextState();
	
	//Startup Procedure
	while(_startup > 0)
	{
		_startup--;
			
	if(_startup % STARTUP_DIVIDER == 0)
			state_delay++;
			 
		setState();
		_delay_ms(state_delay);
		
		_state += _direction;
		if(_state > 6)
			_state = 1;
		else if(_state < 1)
			_state = 6;
	}
///////////////////////////////
	_delay_ms(10);
}

/**
 * @brief sets the State of privat var _state to the outputs
 */
void Brushless_Motorshield::setState()
{
	cli();
	if(_state==1)
	{
		writeState(U,LOW);
		writeState(V,HIGH);
		writeState(W,OFF);
	}
	else if(_state==2)
	{
		writeState(U,OFF);
		writeState(V,HIGH);
		writeState(W,LOW);
	}
	else if(_state==3)
	{
		writeState(U,HIGH);
		writeState(V,OFF);
		writeState(W,LOW);
	}
	else if(_state==4)
	{	
		writeState(U,HIGH);
		writeState(V,LOW);
		writeState(W,OFF);
	}
	else if(_state==5)
	{	
		writeState(U,OFF);
		writeState(V,LOW);
		writeState(W,HIGH);
	}
	else if(_state==6)
	{	
		writeState(U,LOW);
		writeState(V,OFF);
		writeState(W,HIGH);
	}
	sei();
}

/**
 * @brief reads the actual rotor position and sets the next outputstate to _state
 */
void Brushless_Motorshield::readNextState()
{
	uint8_t c = (PIN_SENS_C>>SENS_C)&0x01;//digitalRead(A5);
	uint8_t b = (PIN_SENS_B>>SENS_B)&0x01;//digitalRead(A4);
	uint8_t a = (PIN_SENS_A>>SENS_A)&0x01;//digitalRead(A3);
	
	if(a == 1 && b == 0 && c == 1)
		_state = 1 + _direction;
	else if(a == 0 && b == 0 && c == 1)
		_state = 2 + _direction;
	else if(a == 0 && b == 1 && c == 1)
		_state = 3 + _direction;
	else if(a == 0 && b == 1 && c == 0)
		_state = 4 + _direction;
	else if(a == 1 && b == 1 && c == 0)
		_state = 5 + _direction;
	else if(a == 1 && b == 0 && c == 0)
		_state = 6 + _direction;
		
	if(_state == 7)
		_state = 1;
	else if(_state == 0)
		_state = 6;
	
}

/**
 * @brief stopps the Motor
 */
void Brushless_Motorshield::brake()
{
	writeState(U,OFF);
	writeState(V,OFF);
	writeState(W,OFF);
	_startup = STARTUP_LENGTH;
}

/**
 * @brief writes the given driver State to the outputs
 */
void Brushless_Motorshield::writeOutputState(uint8_t phase, uint8_t driverState)
{
	uint8_t inh = 0;
	uint8_t in = 0;
	
	if(driverState != OFF)
		inh = 1;
		
	if(driverState == HIGH)
		in = 1;
	
	if(phase == U)
	{
		if(in == 1)
			DDR_U |= (1<<U);
		else
			DDR_U &= ~(1<<U);

		if(inh == 1)
			DDR_U_INH |= (1<<U_INH);
		else
			DDR_U_INH &= ~(1<<U_INH);
	}
	else if(phase == V)
	{
		if(in == 1)
			DDR_V |= (1<<V);
		else
			DDR_V &= ~(1<<V);

		if(inh == 1)
			DDR_V_INH |= (1<<V_INH);
		else
			DDR_V_INH &= ~(1<<V_INH);
	}
	else if(phase == W)
	{
		if(in == 1)
			DDR_W |= (1<<W);
		else
			DDR_W &= ~(1<<W);

		if(inh == 1)
			DDR_W_INH |= (1<<W_INH);
		else
			DDR_W_INH &= ~(1<<W_INH);
	}
}

/**
 * @brief controlles the _speed Value to turn the rotor with the given velocity
 */
void Brushless_Motorshield::velocityControllTask()
{
	//(255.0 - MIN_SPEED_VAL) / (MAX_SPEED - MIN_SPEED) * vel
	if (_current_velocity < _velocity - 10.0)
		incSpeedVal(1);
	else if(_current_velocity > _velocity + 10.0)
		decSpeedVal(1);
}

/**
 * @brief increases the speed val by val
 */
void Brushless_Motorshield::incSpeedVal(uint8_t val)
{
	if(_speed + val <= 255)
		_speed = _speed + val;
	OCR2A = _speed;
}

/**
 * @brief decreases the speed val by val
 */
void Brushless_Motorshield::decSpeedVal(uint8_t val)
{
	if(_speed > val)
		_speed = _speed - val;
	OCR2A = _speed;
}

/**
 * @brief sets the internal Speed val
 */
void Brushless_Motorshield::setSpeedVal(uint8_t spd)
{
	if(spd == 0)
		_startup = STARTUP_LENGTH;
	_speed = spd;
	OCR2A = _speed;
}

/**
 * @brief Sets the turn Direction
 */
void Brushless_Motorshield::setDirection(int8_t dir)
{
	if(dir > 0)
		_direction = FORWARD;
	else if(dir < 0)
		_direction = BACKWARD;
}


///////////////////////////////////////////////////
/// public Methods
///////////////////////////////////////////////////
/**
 * @brief gets the current velocity in turns per second
 */
float Brushless_Motorshield::getVelocity()
{
	return _current_velocity * _direction;
}

/**
 * @brief sets the current velocity in turns per second
 */
void Brushless_Motorshield::setVelocity(float vel)
{
	if(vel < 0)
	{
		vel = vel * -1;
		_direction = BACKWARD;
	}
	else
		_direction = FORWARD;
		
	
	_velocity = vel;
	if(_velocity == 0)
		setSpeedVal(0);
	else if(_speed == 0)
		setSpeedVal((255.0 - MIN_SPEED_VAL) / (MAX_SPEED - MIN_SPEED) * vel);
	
	
	if(_startup > 0 && _speed > 0)
		startMotor(); 	
}

//////////////////////////////////////////////////////////////
/// Interrup Service Routines
//////////////////////////////////////////////////////////////
//If the rotor turns 60 degrees this interrupt appears
/**
 * @brief reads the next state and sets it; also the current speed val is computed and the _speed value is corrected
 */
ISR(PCINT_vect) { 
	readNextState();
	
	if(_speed > 0)
		setState();
	else
		brake();

	_avg_count++;
	if(_avg_count==AVG_LENGTH)
	{
		_current_velocity = ((float)AVG_LENGTH) / 6.0 * 7812.0 / (float)_ovf_count;
		_avg_count = 0;
		_ovf_count = 0;
	 
		velocityControllTask(); 
		wdt_reset();
	
	}
}

/**
 * @brief PWM Task
 */
ISR(TIMER2_OVF_vect) {
	if(_speed > 0)
	{
		switch(_state) {
			case 1: 
				PORT_V |= (1<<V);
				PORT_U |= (1<<U_INH); 
			break; // U = PWM
			case 2: 
				PORT_V |= (1<<V);
				PORT_U |= (1<<W_INH);
			break; // V = PWM
			case 3: 
				PORT_V |= (1<<U);
				PORT_U |= (1<<W_INH);
			break; // V = PWM
			case 4: 
				PORT_V |= (1<<U);
				PORT_U |= (1<<V_INH); 
			break; // W = PWM
			case 5: 
				PORT_V |= (1<<W);
				PORT_U |= (1<<V_INH); 
			break; // W = PWM
			case 6: 
				PORT_V |= (1<<W);
				PORT_U |= (1<<U_INH); 
			break; // U = PWM
			default: 
			break;	
		}
	}
		
	if(_speed == 0 || _velocity)
	{
		_speed = 0;
		_startup = STARTUP_LENGTH;
	}
	_ovf_count++;
}



/**
 * @brief PWM Task
 */
ISR(TIMER2_COMPA_vect) {
	switch(_state) {
		case 1: 
			PORT_V &= ~(1<<V);
			PORT_U &= ~(1<<U_INH); 
		break; // U = PWM
		case 2: 
			PORT_V &= ~(1<<V);
			PORT_U &= ~(1<<W_INH);
		break; // V = PWM
		case 3: 
			PORT_V &= ~(1<<U);
			PORT_U &= ~(1<<W_INH);
		break; // V = PWM
		case 4: 
			PORT_V &= ~(1<<U);
			PORT_U &= ~(1<<V_INH); 
		break; // W = PWM
		case 5: 
			PORT_V &= ~(1<<W);
			PORT_U &= ~(1<<V_INH); 
		break; // W = PWM
		case 6: 
			PORT_V &= ~(1<<W);
			PORT_U &= ~(1<<U_INH); 
		break; // U = PWM
		default: 
		break;	
		}
}

/** 
 * @brief watchdog isr: if this occurs the motor did either never start or was forcefully stopped
 */
ISR(WDT_vect) {
	wdt_reset();
	WDTCSR |= (1<<WDCE) | (1<<WDIE); // reenable interrupt to prevent system reset
	_startup = STARTUP_LENGTH;	
	sei();
	if(_startup > 0 && _speed > 0)
		startMotor(); 	
}
